h1. Play 1.0.2 -- Notas de Lançamento

i**Play 1.0.2** é uma versão de manutenção do branch Play 1.0. Dentre os novos recursos, os principais são o suporte ao repositório de módulos e a proteção embutida contra ataques CSRF. Esta versão também corrige um monte de pequenos erros.

p(note). **Play 1.0.2** é uma versão de manutenção e é totalmente compatível com a série 1.0. Se você encontrar algum problema, por favor pergunte-nos no "Google Group":http://groups.google.com/group/play-framework.

Você pode ler sobre os erros corrigidos na "1.0.2 página de road map":http://www.playframework.org/roadmap/1.0.2. As mudanças mais importantes estão realçadas nesta página.

h2. <a>Repositório de Módulos</a>

O objetivo do repositório de módulos é centralizar todos os módulos de contribuições para o Play framework, e permitir uma fácil instalação dos mesmos. Os novos comandos relacionados aos módulos são:

* @play list-modules@, para listar o conteúdo do repositório
* @play install@, para instalar localmente uma versão de um módulo
* @play new-module@, para criar o esqueleto de um novo módulo
* @play build-module@, para empacotar um módulo e publicá-lo no repositório.

Além disso, você verá que quase todos os módulos foram deletados. Somente um punhado de módulos 'core' estão diretamente disponíveis: testunner, docviewer, crud and secure.

Os outros módulos agore são opicionais. Então se você, por exemplo, quiser instalar o suporte a GWT, simplesmente digite @play install gwt@, e você obterá a última versão do módulo.

Por que nós movemos os módulos? Porque nós precisamos focar no core do framework para ter um projeto simples para gerenciar. Além disso, como muitas pessoas querem contribuir com módulos, é mais fácil fazendo desta maneira: cada módulo é um projeto autônomo com um mantenedor dedicado. Então, por favor, se você deseja reportar um erro em um módulo específico, use somente a homepage e o bug tracker deste módulo em questão.

Como benefício imediato, o ciclo de vida dos módulos não é mais amarrado ao ciclo de vida do framework. Um módulo pode ser lançado mais frequentemente que o framework em si. E finalmente, como o framework não contém mais módulos opcionais, o tamanho da distribuição do Play foi reduzido pela metade.

Leia mais sobre o repositório de módulos nesta "página dedicada":modules.

h2. <a>Proteção contra ataques CSRF embutida</a>

Ataques CSRF podem ser relamente problemáticos em uma aplicação web.

bq. Este método de ataque funciona incluindo um código malicioso ou um link em uma página que acessa uma aplicação web na qual o usuário acredita ter se autenticado. Se a sessão desta aplicação web não tiver expirado, um atacante pode executar comandos não autorizados.

Para prevenir este ataque, a primeira coisa à se fazer é utilizar os métodos GET e POST apropriadamente. Isso significa que somente métodos POST deverão ser utilizados para rodar uma interação que pode mudar o estado da aplicação.

Para as requisições POST, o único modo de prover segurança para ações críticas corretamente é emitir um token de autenticidade. O Play 1.0.2 agora tem um helper embutido para manipular isto:

* um novo método @checkAuthenticity()@ está disponível nos controllers, ele checa um token de autenticação válido nos parâmetros da requisição e envia uma resposta forbidden se alguma coisa está ruim
* @session.getAuthenticityToken()@ gera um token de autenticidade que só é válido para a sessão atual
* @#{authenticityToken /}@ cria um hidden input field que você pode adicionar em qualquer form.

Então, por exemplo:

bc. public static destroyMyAccount() {
    checkAuthenticity();
    …
}

Somente irá funcionar quando chamado de um form que tenha incluso um token de autenticidade apropriado:

bc. #{form @ destroyMyAccount()}
    #{authenticityToken /}
    <input type="submit" value="destroy my account">
#{/form}

É claro que você pode adicionar isto antes de um filter se você quiser proteger todas as actions de uma hierarquia de controllers. Leia mais em "Guia de Segurança":security.

h2. <a>Método HEAD suportado por padrão</a>

Play now responds automatically to HEAD requests if there is an existing route for the GET method. This is because it is requested by the HTTP RFC that any resource respond to HEAD request as well.

"http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html":http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html

bq. The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.

So any HEAD request will invoke your action method, but the response content will not be sent to the client. You can of course specialize it by adding a custom route to respond to HEAD requests with your routes file. For example:

bc. GET     /orders/{id}         Orders.show
HEAD    /orders/{id}         Orders.showHead

h2. <a>New sample application, ‘zencontact’</a>

A new sample, that is a port of a "Wicket-based contact management application":http://blog.zenika.com/index.php?post/2009/03/10/Concours-Développer-une-application-web-en-Wicket3. There is also a Scala version of this application available in the Scala module package, for those interested.

!images/zencontact!

h2. <a>Better support for application server deployment</a>

We have tested the deployment of a Play generated WAR archive on several application servers. You can check the current "compatibility matrix":deployment.

|| JBoss 4.2.x || JBoss 5.x || JBoss 6M2 || Glasshfish v3 || IBM Websphere 6.1 ||IBM Websphere 7 || Geronimo 2.x || Tomcat 6.x || Jetty 7.x || Resin 4.0.5 ||
| ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |  ✓ | ✓  |


h2. <a>New features for reversed action in templates</a>

The <code>@@</code> syntax, that allow to reverse an action to an **absolute** URL, is now available in tag parameters. For example:

bc. #{form @@save()}
…
#{/}

It is very useful if you use the template engine to generate stuff like e-mail, in which you need to express URL in an absolute fashion.

Also, binding complex objects in now supported. So for example, with this action:

bc. public static void search(SearchParams params) {
    …
}

SearchParams, being:

bc. public class SearchParams {
    public String keywords;
    public String mode;
}

You can use in a template, something like:

bc. @{search(params)}

That would generate a URL containing several values in the queryString, like:

bc. /search?params.keywords=xxxx&params.mode=AND

h2. <a>A new command to generate the application Javadoc</a>

Now you can generate the **Javadoc** for your project easily, using:

bc. play javadoc

It generates the Javadoc API documentation for your project and its modules.

h2. <a>An even better Eclipse plugin in this release</a>

The Eclipse plugin now has several new features:

* Advanced route file editor, with content assist, missing action detection, and hyperlinks
* Advanced template files editor, with some content assist, and hyperlinks
* Wizard to create new Controllers, Models and Templates
* Integrated test runner (using an embedded web browser)

!images/route-completion!

!images/eclipse-tests!

To install this plugin, copy the JAR file from @$PLAY_HOME/support/eclipse@ to @$ECLIPSE_HOME/dropins@.

p(note). Next release: %(next)"Play 1.0.3 release notes":releasenotes-1.0.3%
